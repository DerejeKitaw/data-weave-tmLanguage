# [PackageDev] target_format: plist, ext: tmLanguage
---
name: DataWeave
scopeName: source.data-weave
fileTypes: [dwl]
uuid: ba6390ae-c50f-4dce-97f1-951dab8fc607

patterns:
- include: '#statements'
- name: comment.line.shebang.dw
  match: \A(#!).*(?=$)
  captures:
    '1': { name: punctuation.definition.comment.dw }

repository:
  statements:
    patterns:
    - include: '#comment'
    - include: '#declaration'
    - include: '#body'
    - include: '#expression'

  declaration:
    patterns:
     - include: '#dw-directive'
     - include: '#decorator'
     - include: '#var-expr'
     - include: '#function-declaration'
     - include: '#type-declaration'
     - include: '#ns-directive'
     - include: '#input-directive'
     - include: '#output-directive'
     - include: '#import-declaration'


  expression:
    patterns:
    - include: '#string'
    - include: '#regex'
    - include: '#template'
    - include: '#comment'
    - include: '#if-expression'
    - include: '#arrow-function'
    - include: '#object-literal'
    - include: '#match-statement'
    - include: '#expression-operators'
    - include: '#function-call'
    - include: '#literal'
    - include: '#identifiers'
    - include: '#paren-expression'
    - include: '#punctuation-comma'
    - include: '#punctuation-accessor'
    


  dw-directive:
    name: meta.directive.ns.dw
    begin: (?<!\.|\$)(%dw)\s+([0-9]\.[0-9])(?!\$|\.)
    beginCaptures:
      '1': { name: comment.dw }
      '2': { name: comment.dw }
    end: (?=\n)

  ns-directive:
    name: meta.directive.ns.dw
    begin: (?<!\.|\$)\b(ns)\s+([[:alpha:]][[:alnum:]]*)\s+([^\n]*)(?!\$|\.)
    beginCaptures:
      '1': { name: storage.type.ns.dw }
      '2': { name: entity.name.ns.dw }
      '3': { name: meta.definition.ns.dw string.url.dw }
    end: (?=\n)


  input-directive:
    name: meta.directive.ns.dw
    begin: (?<!\.|\$)\b(input)\s+([[:alpha:]][[:alnum:]]*)\s+([^\n]*)(?!\$|\.)
    beginCaptures:
      '1': { name: storage.type.ns.dw }
      '2': { name: entity.name.ns.dw }
      '3': { name: meta.definition.ns.dw string.mime.dw }
    end: (?=\n)


  output-directive:
    name: meta.directive.ns.dw
    begin: (?<!\.|\$)\b(output)\s+([[:alpha:]][[:alnum:]]*)(?!\$|\.)
    beginCaptures:
      '1': { name: storage.type.ns.dw }
      '2': { name: meta.definition.ns.dw variable.other.ns.dw }
    end: (?=\n)

  var-expr:
    name: meta.var.expr.dw
    begin: (?<!\.|\$)\b(var)\b(?!\$|\.)
    beginCaptures:
      '1': { name: storage.type.dw }
    end: (?=(}|---)|\bvar\b|\binput\b|\boutput\b|\btype\b|\bfun\b|\bns\b|\bimport\b)
    patterns:
    - include: '#var-single-variable'
    - include: '#variable-initializer'
    - include: '#comment'
    - include: '#punctuation-comma'

  var-single-variable:
    patterns:
    - name: meta.var-single-variable.expr.dw
      begin: ([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])
      beginCaptures:
        '1': { name: meta.definition.variable.dw variable.other.constant.dw }
      end: (?=$|^|[;,=}]|(\s+(of|in)\s+))
      patterns:
      - include: '#var-single-variable-type-annotation'
    - name: meta.var-single-variable.expr.dw
      begin: ([_$[:alpha:]][_$[:alnum:]]*)
      beginCaptures:
        '1': { name: meta.definition.variable.dw variable.other.readwrite.dw }
      end: (?=$|^|[;,=}]|(\s+(of|in)\s+))
      patterns:
      - include: '#var-single-variable-type-annotation'

  var-single-variable-type-annotation:
    patterns:
    - include: '#type-annotation'
    - include: '#string'
    - include: '#comment'  


  object-binding-element:
    patterns:
    - include: '#comment'
    - begin: (?=(([_$[:alpha:]][_$[:alnum:]]*)|(\'([^\'\\]|\\\'|\\)*\')|(\"([^\"\\]|\\\"|\\)*\")|(\[([^\[\]]|\[[^\[\]]*\])+\]))\s*(:))
      end: (?=,|\})
      patterns:
      - include: '#object-binding-element-propertyName'
      - include: '#binding-element'
    - include: '#object-binding-pattern'
    - include: '#variable-initializer'
    - include: '#punctuation-comma'

  object-binding-element-propertyName:
    begin: (?=(([_$[:alpha:]][_$[:alnum:]]*)|(\'([^\'\\]|\\\'|\\)*\')|(\"([^\"\\]|\\\"|\\)*\")|(\[([^\[\]]|\[[^\[\]]*\])+\]))\s*(:))
    end: (:)
    endCaptures:
      '0': { name: punctuation.destructuring.dw }
    patterns:
    - include: '#string'
    - include: '#array-literal'
    - name: variable.object.property.dw
      match: ([_$[:alpha:]][_$[:alnum:]]*)

  binding-element:
    patterns:
    - include: '#comment'
    - include: '#object-binding-pattern'
    - include: '#array-binding-pattern'
    - include: '#variable-initializer'


  object-binding-pattern:
    begin: (?:(~)\s*)?(\{)
    beginCaptures:
      '1': { name: keyword.operator.rest.dw }
      '2': { name: punctuation.definition.binding-pattern.object.dw }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.binding-pattern.object.dw }
    patterns:
    - include: '#object-binding-element'

  array-binding-pattern:
    begin: (?:(~)\s*)?(\[)
    beginCaptures:
      '1': { name: keyword.operator.rest.dw }
      '2': { name: punctuation.definition.binding-pattern.array.dw }
    end: \]
    endCaptures:
      '0': { name: punctuation.definition.binding-pattern.array.dw }
    patterns:
    - include: '#binding-element'
    - include: '#punctuation-comma'



  if-part-expression:
    name: switch-expression.expr.ts
    begin: (?<!\.|\$)\b(if)\s*(\()
    beginCaptures:
      '1': { name: keyword.control.if.ts }
      '2': { name: meta.brace.round.ts }
    end: \)
    endCaptures:
      '0': { name: meta.brace.round.ts }
    patterns:
    - include: '#expression'

  if-expression:
    name: if-statement.expr.ts
    begin: (?<!\.|\$)(?=\bif\s*\()
    end: \n
    endCaptures:
      '0': {name: punctuation.definition.block.ts}      
    patterns:
    - include: '#if-part-expression'
    - name: keyword.control.else.ts
      match: (?<!\.|\$)\b(else)\s*



  control-statement:
    # TODO: convert this to actual statements instead
    patterns:
    - name: keyword.control.conditional.dw
      match: (?<!\.|\$)\b(else|if)\b(?!\$|\.)
    - name: keyword.control.with.dw
      match: (?<!\.|\$)\b(using)\b(?!\$|\.)


  body:
    name: meta.body.dw
    begin: (\-\-\-)
    beginCaptures:
      '0': { name: comment.template.dw }
    end: (?:"\\END OF FILE")
    patterns:
    - include: '#expression'

  decorator:
    name: meta.decorator.dw
    begin: (?<!\.|\$)\@
    beginCaptures:
      '0': { name: punctuation.decorator.dw }
    end: (?=\s)
    patterns:
    - include: '#expression'

  type-declaration:
    name: meta.type.declaration.dw
    begin: (?<!\.|\$)\b(type)\b\s+([_$[:alpha:]][_$[:alnum:]]*)\s*
    beginCaptures:
      '1': { name: storage.type.type.dw }
      '2': { name: entity.name.type.alias.dw }
    end: (?=(}|---)|\bvar\b|\binput\b|\boutput\b|\btype\b|\bfun\b|\bns\b|\bimport\b)
    patterns:
      - include: '#comment'
      - include: '#type-parameters'
      - include: '#type'
      - match: '(=)\s*'
        captures:
          '1': { name: keyword.operator.assignment.dw }

  import-declaration:
    name: meta.import.dw
    begin: (?<!\.|\$)\b(import)(?!(\s*:)|(\$|\.))\b
    beginCaptures:
      '1': { name: keyword.control.import.dw }
    end: (?=;|$)
    patterns:
    - include: '#import-export-declaration'
  
  import-export-declaration:
    patterns:
    - include: '#comment'
    - include: '#string'
    - name: keyword.control.from.dw
      match: \bfrom\b
    - include: '#import-export-clause'

  import-export-clause:
    patterns:
    - include: '#comment'
    - comment: (default|*|name) as alias
      match: |- 
        (?x) (?: \b(default)\b | (\*) | ([_$[:alpha:]][_$[:alnum:]]*)) \s+ 
          (as) \s+ (?: (\b default \b | \*) | ([_$[:alpha:]][_$[:alnum:]]*))
      captures:
        '1': { name: keyword.control.default.dw }
        '2': { name: constant.language.import-export-all.dw }
        '3': { name: variable.other.readwrite.dw }
        '4': { name: keyword.control.as.dw }
        '5': { name: invalid.illegal.dw }
        '6': { name: variable.other.readwrite.alias.dw }
    - include: '#punctuation-comma'
    - name: constant.language.import-export-all.dw
      match: \*
    - name: keyword.control.default.dw
      match: \b(default)\b
    - name: variable.other.readwrite.alias.dw
      match: ([_$[:alpha:]][_$[:alnum:]]*)

  type-object:
    name: meta.object.type.dw
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.block.dw }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.dw }
    patterns:
    - include: '#comment'
    - include: '#method-declaration'
    - include: '#indexer-declaration'
    - include: '#indexer-mapped-type-declaration'
    - include: '#field-declaration'
    - include: '#type-annotation'
    - begin: \.\.\.
      beginCaptures:
        '0': { name: keyword.operator.spread.dw }
      end: '(?=\}|;|,|$)|(?<=\})'
      patterns:
      - include: '#type'
    - include: '#punctuation-comma'
    - include: '#type'
    

  field-declaration:
    name: meta.field.declaration.dw
    begin: (?<!\()(?:(?<!\.|\$)\b(readonly)\s+)?(?=(([_$[:alpha:]][_$[:alnum:]]*)|(\'([^\'\\]|\\\'|\\)*\')|(\"([^\"\\]|\\\"|\\)*\")|(\[([^\[\]]|\[[^\[\]]*\])+\]))\s*(\?\s*)?(=|:))
    beginCaptures:
      '1': { name: storage.modifier.dw }
    end: (?=\}|;|,|$|(^(?!(([_$[:alpha:]][_$[:alnum:]]*)|(\'([^\'\\]|\\\'|\\)*\')|(\"([^\"\\]|\\\"|\\)*\")|(\[([^\[\]]|\[[^\[\]]*\])+\]))\s*(\?\s*)?(=|:))))|(?<=\})
    patterns:
    - include: '#variable-initializer'
    - begin: (?=((?:[_$[:alpha:]][_$[:alnum:]]*)|(\'([^\'\\]|\\\'|\\)*\')|(\"([^\"\\]|\\\"|\\)*\")|(\[([^\[\]]|\[[^\[\]]*\])+\]))\s*(\?\s*)?(=|:))
      end: (?=[};,=]|$|(^(?!(([_$[:alpha:]][_$[:alnum:]]*)|(\'([^\'\\]|\\\'|\\)*\')|(\"([^\"\\]|\\\"|\\)*\")|(\[([^\[\]]|\[[^\[\]]*\])+\]))\s*(\?\s*)?(=|:))))|(?<=\})
      patterns:
      - include: '#type-annotation'
      - include: '#string'
      - include: '#array-literal'
      - include: '#comment'
      - name: meta.definition.property.dw variable.object.property.dw
        match: '[_$[:alpha:]][_$[:alnum:]]*'
      - name: keyword.operator.optional.dw
        match: \?

  method-declaration:
    patterns:
    - name: meta.method.declaration.dw
      begin: (?<!\.|\$)(?:\b(public|private|protected)\s+)?(?:\b(abstract)\s+)?(?:\b(async)\s+)?(?:\b(get|set)\s+)(?:(\*)\s*)?(?=((([_$[:alpha:]][_$[:alnum:]]*)|(\'([^\'\\]|\\\'|\\)*\')|(\"([^\"\\]|\\\"|\\)*\")|(\[([^\[\]]|\[[^\[\]]*\])+\]))\s*(\??))\s*[\(\<])
      beginCaptures:
        '1': { name: storage.modifier.dw } # captures keyword (public or private or protected)
        '2': { name: storage.modifier.dw } # captures keyword (abstract)
        '3': { name: storage.modifier.async.dw } # captures keyword (async)
        '4': { name: storage.type.property.dw } # captures keyword (get|set)
        '5': { name: keyword.generator.asterisk.dw } # captures keyword (*)
      end: (?=\}|;|,|$)|(?<=\})
      patterns:
      - include: '#method-declaration-name'
      - include: '#comment'
      - include: '#type-parameters'
      - include: '#function-parameters'
      - include: '#return-type'
      - include: '#decl-block'
    - name: meta.method.declaration.dw
      begin: (?<!\.|\$)(?:\b(public|private|protected)\s+)?(?:\b(abstract)\s+)?(?:\b(async)\s+)?(?:(?:\b(?:(new)|(constructor))\b(?!\$|\.|:))|(?:(\*)\s*)?(?=((([_$[:alpha:]][_$[:alnum:]]*)|(\'([^\'\\]|\\\'|\\)*\')|(\"([^\"\\]|\\\"|\\)*\")|(\[([^\[\]]|\[[^\[\]]*\])+\]))\s*(\??))?\s*[\(\<]))
      beginCaptures:
        '1': { name: storage.modifier.dw } # captures keyword (public or private or protected)
        '2': { name: storage.modifier.dw } # captures keyword (abstract)
        '3': { name: storage.modifier.async.dw } # captures keyword (async)
        '4': { name: keyword.operator.new.dw } # captures keyword (new)
        '5': { name: storage.type.dw } # captures keyword (constructor)
        '6': { name: keyword.generator.asterisk.dw } # captures keyword (*)
      end: (?=\}|;|,|$)|(?<=\})
      patterns:
      - include: '#method-declaration-name'
      - include: '#comment'
      - include: '#type-parameters'
      - include: '#function-parameters'
      - include: '#return-type'
      - include: '#decl-block'

  method-declaration-name:
    begin: (?=(([_$[:alpha:]][_$[:alnum:]]*)|(\'([^\'\\]|\\\'|\\)*\')|(\"([^\"\\]|\\\"|\\)*\")|(\[([^\[\]]|\[[^\[\]]*\])+\]))\s*(\??)\s*[\(\<])
    end: (?=\(|\<)
    patterns:
    - include: '#string'
    - include: '#array-literal'
    - name: meta.definition.method.dw entity.name.function.dw
      match: '[_$[:alpha:]][_$[:alnum:]]*'
    - name: keyword.operator.optional.dw
      match: \?

  object-literal-method-overload-declaration:
    begin: (?<!\.|\$)(?:\b(async)\s+)?(?:\b(get|set)\s+)?(?:(\*)\s*)?(?=((([_$[:alpha:]][_$[:alnum:]]*)|(\'([^\'\\]|\\\'|\\)*\')|(\"([^\"\\]|\\\"|\\)*\")|(\[([^\[\]]|\[[^\[\]]*\])+\]))\s*(\??))\s*[\(\<])
    beginCaptures:
      '1': { name: storage.modifier.async.dw } # captures keyword (async)
      '2': { name: storage.type.property.dw } # captures keyword (get|set)
      '3': { name: keyword.generator.asterisk.dw } # captures keyword (*)
    end: (?=\(|\<)
    patterns:
    - include: '#method-declaration-name'

  indexer-declaration:
    name: meta.indexer.declaration.dw
    begin: (?:(?<!\.|\$)\b(readonly)\s*)?(\[)\s*([_$[:alpha:]][_$[:alnum:]]*)\s*(?=:)
    beginCaptures:
      '1': { name: storage.modifier.dw }
      '2': { name: meta.brace.square.dw }
      '3': { name: variable.parameter.dw}
    end: (\])\s*(\?\s*)?|$
    endCaptures:
      '1': { name: meta.brace.square.dw }
      '2': { name: keyword.operator.optional.dw }
    patterns:
    - include: '#type-annotation'

  indexer-mapped-type-declaration:
    name: meta.indexer.mappedtype.declaration.dw
    begin: (?:(?<!\.|\$)\b(readonly)\s*)?(\[)\s*([_$[:alpha:]][_$[:alnum:]]*)\s+(in)\s+
    beginCaptures:
      '1': { name: storage.modifier.dw }
      '2': { name: meta.brace.square.dw }
      '3': { name: entity.name.type.dw }
      '4': { name: keyword.operator.expression.in.dw }
    end: (\])\s*(\?\s*)?|$
    endCaptures:
      '1': { name: meta.brace.square.dw }
      '2': { name: keyword.operator.optional.dw }
    patterns:
    - include: '#type'

  function-declaration:
    name: meta.function.dw
    begin: (?<!\.|\$)\b(fun\b)(?:(?:\s+|(?<=\*))([_$[:alpha:]][_$[:alnum:]]*))?\s*
    beginCaptures:
      '1': { name: storage.type.function.dw }
      '2': { name: meta.definition.function.dw entity.name.function.dw }
    end: (?=(}|---)|\bvar\b|\binput\b|\boutput\b|\btype\b|\bfun\b|\bns\b|\bimport\b)
    patterns:
    - include: '#comment'
    - include: '#type-parameters'
    - include: '#function-parameters'
    - include: '#return-type'
    - include: '#decl-block'

  object-literal:
    name: meta.objectliteral.dw
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.block.dw }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.dw }
    patterns:
    - include: '#object-member'

  decl-block:
    name: meta.block.dw
    begin: \=
    beginCaptures:
      '0': { name: punctuation.definition.block.dw }
    end: (?=(}|---)|\bvar\b|\binput\b|\boutput\b|\btype\b|\bfun\b|\bns\b|\bimport\b)
    patterns:
    - include: '#expression'

  after-operator-block:
    name: meta.objectliteral.dw
    begin: (?<=[=(,\[?+!]|await|return|yield|throw|in|of|typeof|&&|\|\||\*)\s*(\{)
    beginCaptures:
      '1': { name: punctuation.definition.block.dw }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.dw }
    patterns:
    - include: '#object-member' 

  parameter-name:
    patterns:
    - match: \s*\b(public|protected|private|readonly)(?=\s+(public|protected|private|readonly)\s+)
      captures:
        '1': { name: storage.modifier.dw }
    # function assignment |
    # typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>
    - match: |-
        (?x)(?:\s*\b(public|private|protected|readonly)\s+)?(\.\.\.)?\s*(?<!=|:)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\s*(\??)(?=\s*
          (=\s*(
            ((async\s+)?(
              (function\s*[(<*]) |
              (function\s+) |
              ([_$[:alpha:]][_$[:alnum:]]*\s*=>)
            )) |
            ((async\s*)?(
              ([(]\s*(([)]\s*:)|([_$[:alpha:]][_$[:alnum:]]*\s*:)|(\.\.\.) )) |
              ([<]\s*[_$[:alpha:]][_$[:alnum:]]*((\s+extends\s*[^=>])|(\s*[,]))) |
              ((<([^<>=]|=[^<]|\<([^=<>]|=[^<])+\>)+>\s*)?\(([^()]|\([^()]*\))*\)(\s*:\s*(.)*)?\s*=>)
            ))
          )) |
          (:\s*(
            (<) |
            ([(]\s*(
              ([)]) |
              (\.\.\.) |
              ([_$[:alnum:]]+\s*(
                ([:,?=])|
                ([)]\s*=>)
              ))
            ))
          ))
        )
      captures:
        '1': { name: storage.modifier.dw }
        '2': { name: keyword.operator.rest.dw }
        '3': { name: entity.name.function.dw variable.language.this.dw }
        '4': { name: entity.name.function.dw }
        '5': { name: keyword.operator.optional.dw }
    - match: (?:\s*\b(public|private|protected|readonly)\s+)?(\.\.\.)?\s*(?<!=|:)(?:((?<!\.|\$)\bthis\b(?!\.|\$))|([_$[:alpha:]][_$[:alnum:]]*))\s*(\??)
      captures:
        '1': { name: storage.modifier.dw }
        '2': { name: keyword.operator.rest.dw }
        '3': { name: variable.parameter.dw variable.language.this.dw }
        '4': { name: variable.parameter.dw }
        '5': { name: keyword.operator.optional.dw }

  destructuring-parameter:
    patterns:
    - name: meta.parameter.object-binding-pattern.dw
      begin: (?<!=|:)\s*(\{)
      beginCaptures:
        '1': { name: punctuation.definition.binding-pattern.object.dw }
      end: \}
      endCaptures:
        '0': { name: punctuation.definition.binding-pattern.object.dw }
      patterns:
      - include: '#parameter-object-binding-element'
    - name: meta.paramter.array-binding-pattern.dw
      begin: (?<!=|:)\s*(\[)
      beginCaptures:
        '1': { name: punctuation.definition.binding-pattern.array.dw }
      end: \]
      endCaptures:
        '0': { name: punctuation.definition.binding-pattern.array.dw }
      patterns:
      - include: '#parameter-binding-element'
      - include: '#punctuation-comma'

  parameter-object-binding-element:
    patterns:
    - include: '#comment'
    - begin: (?=(([_$[:alpha:]][_$[:alnum:]]*)|(\'([^\'\\]|\\\'|\\)*\')|(\"([^\"\\]|\\\"|\\)*\")|(\[([^\[\]]|\[[^\[\]]*\])+\]))\s*(:))
      end: (?=,|\})
      patterns:
      - include: '#object-binding-element-propertyName'
      - include: '#parameter-binding-element'
    - include: '#parameter-object-binding-pattern'
    - include: '#destructuring-parameter-rest'
    - include: '#variable-initializer'
    - include: '#punctuation-comma'

  parameter-binding-element:
    patterns:
    - include: '#comment'
    - include: '#parameter-object-binding-pattern'
    - include: '#parameter-array-binding-pattern'
    - include: '#destructuring-parameter-rest'
    - include: '#variable-initializer'

  destructuring-parameter-rest:
    match: (?:(\.\.\.)\s*)?([_$[:alpha:]][_$[:alnum:]]*)
    captures:
      '1': { name: keyword.operator.rest.dw }
      '2': { name: variable.parameter.dw }

  parameter-object-binding-pattern:
    begin: (?:(\.\.\.)\s*)?(\{)
    beginCaptures:
      '1': { name: keyword.operator.rest.dw }
      '2': { name: punctuation.definition.binding-pattern.object.dw }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.binding-pattern.object.dw }
    patterns:
    - include: '#parameter-object-binding-element'

  parameter-array-binding-pattern:
    begin: (?:(\.\.\.)\s*)?(\[)
    beginCaptures:
      '1': { name: keyword.operator.rest.dw }
      '2': { name: punctuation.definition.binding-pattern.array.dw }
    end: \]
    endCaptures:
      '0': { name: punctuation.definition.binding-pattern.array.dw }
    patterns:
    - include: '#parameter-binding-element'
    - include: '#punctuation-comma'

  return-type:
    patterns:
    # if type starts on same line use end of line as end
    - name: meta.return.type.dw
      begin: (?<=\))\s*(:)(?=\s*\S)
      beginCaptures:
        '1': { name: keyword.operator.type.annotation.dw }
      end: (?<![:|&])(?=$|^|[{};,]|//)
      patterns:
      - include: '#return-type-core'
    # if type starts on next line use modified line endings as end of type annotation eg. complete empty line
    - name: meta.return.type.dw
      begin: (?<=\))\s*(:)
      beginCaptures:
        '1': { name: keyword.operator.type.annotation.dw }
      end: (?<![:|&])((?=[{};,]|//|^\s*$)|((?<=\S)(?=\s*$)))
      patterns:
      - include: '#return-type-core'

  return-type-core:
    patterns:
    - include: '#comment'
    # Handle returning of object type specifically here so as to not confuse it with the start of function block
    - begin: (?<=[:|&])(?=\s*\{)
      end: (?<=\})
      patterns:
      - include: '#type-object'
    - include: '#type-predicate-operator'
    - include: '#type'

  type-predicate-operator:
    name: keyword.operator.expression.is.dw
    match: (?<!\.|\$)\bis\b(?!\$|\.)

  type-annotation:
    patterns:
    # if type starts on same line use end of line as end
    - name: meta.type.annotation.dw
      begin: (:)(?=\s*\S)
      beginCaptures:
        '1': { name: keyword.operator.type.annotation.dw }
      end: (?<![:|&])((?=$|^|[,);\}\]]|//)|(?==[^>])|((?<=[\}>\]\)]|[_$[:alpha:]])\s*(?=\{)))
      patterns:
      - include: '#type'
    # if type starts on next line use modified line endings as end of type annotation eg. complete empty line
    - name: meta.type.annotation.dw
      begin: (:)
      beginCaptures:
        '1': { name: keyword.operator.type.annotation.dw }
      end: (?<![:|&])((?=[,);\}\]]|//)|(?==[^>])|(?=^\s*$)|((?<=\S)(?=\s*$))|((?<=[\}>\]\)]|[_$[:alpha:]])\s*(?=\{)))
      patterns:
      - include: '#type'

  type:
    patterns:
    - include: '#comment'
    - include: '#string'
    - include: '#numeric-literal'
    - include: '#type-primitive'
    - include: '#type-builtin-literals'
    - include: '#type-parameters'
    - include: '#type-tuple'
    - include: '#type-object'
    - include: '#type-operators'
    - include: '#type-fn-type-parameters'
    - include: '#type-paren-or-function-parameters'
    - include: '#type-function-return-type'
    - include: '#type-name'

  function-parameters:
    name: meta.parameters.dw
    begin: \(
    beginCaptures:
      '0': { name: punctuation.definition.parameters.begin.dw }
    end: \)
    endCaptures:
      '0': { name: punctuation.definition.parameters.end.dw }
    patterns:
    - include: '#comment'
    - include: '#decorator'
    - include: '#destructuring-parameter'
    - include: '#parameter-name'
    - include: '#type-annotation'
    - include: '#variable-initializer'
    - name: punctuation.separator.parameter.dw
      match: ','

  type-primitive:
    name: support.type.primitive.dw
    match: (?<!\.|\$)\b(string|number|boolean|symbol|any|void|never)\b(?!\$|\.)

  type-builtin-literals:
    name: support.type.builtin.dw
    match: (?<!\.|\$)\b(this|true|false|undefined|null|object)\b(?!\$|\.)

  # Parenthesis can contain either types and function parameters
  # (number | string) or (param: number, param2: string)
  # and it can be nested, for example
  # (number | (param: number, param2: string) => void)
  type-paren-or-function-parameters:
    name: meta.type.paren.cover.dw
    begin: \(
    beginCaptures:
      '0': { name: meta.brace.round.dw }
    end: \)
    endCaptures:
      '0': { name: meta.brace.round.dw }
    patterns:
    - include: '#type'
    - include: '#function-parameters'

  type-fn-type-parameters:
    patterns:
    # constructor type
    - name: meta.type.constructor.dw
      match: (?<!\.|\$)\b(new)\b(?=\s*\<)
      captures:
        '1': { name: keyword.control.new.dw }
    - name: meta.type.constructor.dw
      begin: (?<!\.|\$)\b(new)\b\s*(?=\()
      beginCaptures:
        '1': { name: keyword.control.new.dw }
      end: (?<=\))
      patterns:
      - include: '#function-parameters'
    # () | (... | (param: | (param, | (param? | (param= | (param) =>
    - name: meta.type.function.dw
      begin: |-
        (?x)(
          (?=
            [(]\s*(
              ([)]) | 
              (\.\.\.) |
              ([_$[:alnum:]]+\s*(
                ([:,?=])|
                ([)]\s*=>)
              ))
            )
          )
        )
      end: (?<=\))
      patterns:
      - include: '#function-parameters'

  type-operators:
    patterns:
    - include: '#typeof-operator'
    # Handle the object types followed by | or & operator as { can be used as end of Type in many places and this avoids tripping that
    - begin: ([&|])(?=\s*\{)
      beginCaptures:
         '0': { name: keyword.operator.type.dw }
      end: (?<=\})
      patterns:
      - include: '#type-object'
    # capture all white spaces followed by the | or & operator so that line break (which is end regex for many type patterns) 
    # will be consumed and we will continue to be in type space
    - begin: '[&|]'
      beginCaptures:
         '0': { name: keyword.operator.type.dw }
      end: (?=\S)
    - name: keyword.operator.expression.keyof.dw
      match: (?<!\.|\$)\bkeyof\b(?!\$|\.)

  type-function-return-type:
    patterns:
    # if type starts on same line use end of line as end
    - name: meta.type.function.return.dw
      begin: (=>)(?=\s*\S)
      beginCaptures:
        '1': { name: storage.type.function.arrow.dw }
      end: (?<!=>)(?<![|&])(?=[,\]\)\{\}=;>]|//|$)
      patterns:
      - include: '#type-function-return-type-core'
    # if type starts on next line use modified line endings as end of type annotation eg. complete empty line
    - name: meta.type.function.return.dw
      begin: '=>'
      beginCaptures:
        '0': { name: storage.type.function.arrow.dw }
      end: (?<!=>)(?<![|&])((?=[,\]\)\{\}=;>]|//|^\s*$)|((?<=\S)(?=\s*$)))
      patterns:
      - include: '#type-function-return-type-core'

  type-function-return-type-core:
      patterns:
      - include: '#comment'
      # Handle returning of object type specifically here so as to not confuse it with the start of function block
      - begin: (?<==>)(?=\s*\{)
        end: (?<=\})
        patterns:
        - include: '#type-object'
      - include: '#type-predicate-operator'
      - include: '#type'

  type-tuple:
    name: meta.type.tuple.dw
    begin: \[
    beginCaptures:
      '0': { name: meta.brace.square.dw }
    end: \]
    endCaptures:
      '0': { name: meta.brace.square.dw }
    patterns:
    - include: '#type'
    - include: '#punctuation-comma'

  type-name:
    patterns:
    - match: ([_$[:alpha:]][_$[:alnum:]]*)\s*(\.)
      captures:
        '1': { name: entity.name.type.module.dw }
        '2': { name: punctuation.accessor.dw }
    - name: entity.name.type.dw
      match: '[_$[:alpha:]][_$[:alnum:]]*'

  type-parameters:
    name: meta.type.parameters.dw
    begin: '(<)'
    beginCaptures:
      '1': { name: punctuation.definition.typeparameters.begin.dw }
    end: '(>)'
    endCaptures:
      '1': { name: punctuation.definition.typeparameters.end.dw }
    patterns:
    - include: '#comment'
    - name: storage.modifier.dw
      match: (?<!\.|\$)(<:)(?!\$)
    - name: keyword.operator.assignment.dw
      match: \=(?!>)
    - include: '#type'
    - include: '#punctuation-comma'

  variable-initializer:
    patterns:
    # if it is assignment with expression on same line, use end of line as end of scope
    - begin: (?<!=|!)(=)(?!=)(?=\s*\S)
      beginCaptures:
        '1': { name: keyword.operator.assignment.dw }
      end: (?=$|^|[,);}\]])
      patterns:
      - include: '#expression'
    # if the expression doesnt start on same line do not use end of line as end of unless the complete line is blank
    - begin: (?<!=|!)(=)(?!=)
      beginCaptures:
        '1': { name: keyword.operator.assignment.dw }
      end: (?=[,);}\]])|(?=^\s*$)|(?<=\S)(?<!=)(?=\s*$)
      patterns:
        - include: '#expression'

  for-loop:
    begin: (?<!\.|\$)\b(for)(?:\s+(await))?\s*(\()
    beginCaptures:
      '1': { name: keyword.control.loop.dw }
      '2': { name: keyword.control.loop.dw }
      '3': { name: meta.brace.round.dw }
    end: \)
    endCaptures:
      '0': { name: meta.brace.round.dw }
    patterns:
    - include: '#var-expr'
    - include: '#expression'

  match-expression:
    name: match-expression.expr.dw
    begin: (?<!\.|\$)\b(match)\s*(\()
    beginCaptures:
      '1': { name: keyword.control.match.dw }
      '2': { name: meta.brace.round.dw }
    end: \)
    endCaptures:
      '0': { name: meta.brace.round.dw }
    patterns:
    - include: '#expression'

  match-block:
    name: match-block.expr.dw
    begin: \{
    beginCaptures:
      '0': { name: keyword.control.switch.dw }
    end: (?=\})
    patterns:
    - include: '#case-clause'
    - include: '#expression'

  case-clause:
    name: case-clause.expr.dw
    begin: (?<!\.|\$)\b(case|else(?=\s*->))\b(?!\$|\.)
    beginCaptures:
      '1': { name: keyword.control.switch.dw }
    end: \-\>
    endCaptures:
      '0': { name: keyword.control.switch.dw }
    patterns:
    - begin: (?<!\.|\$)\b(is)\s+
      beginCaptures:
        '1': { name: keyword.control.as.dw }
      end: (?=\-\>)
      patterns:
      - include: '#type'
    - include: '#expression'

  match-statement:
    name: match-statement.expr.dw
    begin: (?<!\.|\$)\b(match\s*)(?=\{)
    beginCaptures:
      '0': {name: keyword.control.switch.dw }
    end: \}
    endCaptures: 
      '0': {name: keyword.control.switch.dw }      
      '1': {name: punctuation.definition.block.dw}      
    patterns:
    - include: '#match-block'

  function-call:
    begin: (?=(([_$[:alpha:]][_$[:alnum:]]*\s*\.\s*)*|(\.\s*)?)([_$[:alpha:]][_$[:alnum:]]*)\s*(<([^<>=]|=[^<]|\<([^=<>]|=[^<])+\>)+>\s*)?\()
    end: (?<=\))(?!(([_$[:alpha:]][_$[:alnum:]]*\s*\.\s*)*|(\.\s*)?)([_$[:alpha:]][_$[:alnum:]]*)\s*(<([^<>=]|=[^<]|\<([^=<>]|=[^<])+\>)+>\s*)?\()
    patterns:
    - name: meta.function-call.dw
      begin: (?=(([_$[:alpha:]][_$[:alnum:]]*\s*\.\s*)*|(\.\s*)?)([_$[:alpha:]][_$[:alnum:]]*))
      end: (?=\s*(<([^<>=]|=[^<]|\<([^=<>]|=[^<])+\>)+>\s*)?\()
      patterns:
      - include: '#literal'
      - include: '#object-identifiers'
      - include: '#punctuation-accessor'
      - name: keyword.operator.expression.import.dw
        match: (?![\.\$])\bimport(?=\s*[\(]\s*[\"\'\`])
      - name: entity.name.function.dw
        match: ([_$[:alpha:]][_$[:alnum:]]*)
    - include: '#comment'
    - name: meta.type.parameters.dw
      begin: \<
      beginCaptures:
        '0': { name: punctuation.definition.typeparameters.begin.dw }
      end: \>
      endCaptures:
        '0': { name: punctuation.definition.typeparameters.end.dw }
      patterns:
      - include: '#type'
      - include: '#punctuation-comma'
    - include: '#paren-expression'

  identifiers:
    patterns:
    - include: '#object-identifiers'
    # function and method assignment
    - match: |-
        (?x)(?:(\.)\s*)?([_$[:alpha:]][_$[:alnum:]]*)(?=\s*=\s*(
          ((async\s+)?(
            (function\s*[(<*]) |
            (function\s+) |
            ([_$[:alpha:]][_$[:alnum:]]*\s*=>)
          )) |
          ((async\s*)?(
            ([(]\s*(([)]\s*:)|([_$[:alpha:]][_$[:alnum:]]*\s*:)|(\.\.\.) )) |
            ([<]\s*[_$[:alpha:]][_$[:alnum:]]*((\s+extends\s*[^=>])|(\s*[,]))) |
            ((<([^<>=]|=[^<]|\<([^=<>]|=[^<])+\>)+>\s*)?\(([^()]|\([^()]*\))*\)(\s*:\s*(.)*)?\s*=>)
          ))
        ))
      captures:
        '1': { name: punctuation.accessor.dw }
        '2': { name: entity.name.function.dw }
    # const properties
    - match: (\.)\s*([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])
      captures:
        '1': { name: punctuation.accessor.dw }
        '2': { name: variable.other.constant.property.dw }
    # properties
    - match: (\.)\s*([_$[:alpha:]][_$[:alnum:]]*)
      captures:
        '1': { name: punctuation.accessor.dw }
        '2': { name: variable.other.property.dw }
    # const
    - name: variable.other.constant.dw
      match: ([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])
    # vars
    - name: variable.other.readwrite.dw
      match: '[_$[:alpha:]][_$[:alnum:]]*'

  object-identifiers:
    patterns:
    # class
    - name: support.class.dw
      match: ([_$[:alpha:]][_$[:alnum:]]*)(?=\s*\.\s*prototype\b(?!\$))
    # object properties
    - match: |-
        (?x)(\.)\s*(?:
          ([[:upper:]][_$[:digit:][:upper:]]*) |
          ([_$[:alpha:]][_$[:alnum:]]*)
        )(?=\s*\.\s*[_$[:alpha:]][_$[:alnum:]]*)
      captures:
        '1': { name: punctuation.accessor.dw }
        '2': { name: variable.other.constant.object.property.dw }
        '3': { name: variable.other.object.property.dw }
    # objects
    - match: |-
        (?x)(?:
          ([[:upper:]][_$[:digit:][:upper:]]*) |
          ([_$[:alpha:]][_$[:alnum:]]*)
        )(?=\s*\.\s*[_$[:alpha:]][_$[:alnum:]]*)
      captures:
        '1': { name: variable.other.constant.object.dw }
        '2': { name: variable.other.object.dw }


  object-member:
    patterns:
    - include: '#comment'
    - include: '#paren-expression'
    - name: meta.object.member.dw meta.object-literal.key.dw
      begin: (?=[\'\"])
      end: (?=:)
      patterns:
      - include: '#string'

    - name: meta.object.member.dw
      match: \b([[:alpha:]][[:alnum:]]+#)
      captures:
        '0': { name: entity.name.ns.dw }

    - name: meta.object.member.dw
      match: (?![_$[:alpha:]])([[:digit:]]+)\s*(?=:)
      captures:
        '0': { name: meta.object-literal.key.dw }
        '1': { name: constant.numeric.decimal.dw }
    - name: meta.object.member.dw
      match: |-
        (?x)(?:([_$[:alpha:]][_$[:alnum:]]*)\s*(?=:\s*(
          ((async\s+)?(
            (function\s*[(<*]) |
            (function\s+) |
            ([_$[:alpha:]][_$[:alnum:]]*\s*=>)
          )) |
          ((async\s*)?(
            ([(]\s*(([)]\s*:)|([_$[:alpha:]][_$[:alnum:]]*\s*:)|(\.\.\.) )) |
            ([<]\s*[_$[:alpha:]][_$[:alnum:]]*((\s+extends\s*[^=>])|(\s*[,]))) |
            ((<([^<>=]|=[^<]|\<([^=<>]|=[^<])+\>)+>\s*)?\(([^()]|\([^()]*\))*\)(\s*:\s*(.)*)?\s*=>)
          ))
        )))
      captures:
        '0': { name: meta.object-literal.key.dw }
        '1': { name: entity.name.function.dw }
    - name: meta.object.member.dw
      match: (?:[_$[:alpha:]][_$[:alnum:]]*)\s*(?=:)
      captures:
        '0': { name: meta.object-literal.key.dw }
      end: (?=,|\})
    - include: '#object-member-body'
    - include: '#punctuation-comma'

  object-member-body:
    name:  meta.object.member.dw
    begin: ':'
    beginCaptures:
      '0': { name: meta.object-literal.key.dw punctuation.separator.key-value.dw }
    end: (?=,|\})
    patterns:
    - include: '#expression'

  expression-operators:
    patterns:
    - name: keyword.operator.expression.void.dw
      match: (?<!\.|\$)\bnot\b(?!\$|\.)
      #handle as operator specifically to be recognized only if it is 'as' followed by space
    - begin: (?<!\.|\$)\b(as|is)\s+
      beginCaptures:
        '1': { name: keyword.control.as.dw }
      end: (?=$|^|[;,:})\]])
      patterns:
      - include: '#type'
    - name: keyword.operator.spread.dw
      match: '~'
    - name: keyword.operator.bitwise.shift.dw
      match: <<|>>>|>>
    - name: keyword.operator.comparison.dw
      match: ==|!=
    - name: keyword.operator.relational.dw
      match: <=|>=|<|>
    - name: keyword.operator.logical.dw
      match: and|or
    - name: keyword.operator.bitwise.dw
      match: \&|~|\^|\|
    - name: keyword.operator.assignment.dw
      match: \=
    - name: keyword.operator.decrement.dw
      match: --
    - name: keyword.operator.increment.dw
      match: \+\+
    - name: keyword.operator.arithmetic.dw
      match: '%|\*|/|-|\+'
    # capture the arithmetic sign followed by variable or parenthesized expression so that it is not interpreted as regex
    - match: (?<=[_$[:alnum:])])\s*(/)(?![/*])
      captures:
        '1': { name: keyword.operator.arithmetic.dw }

  typeof-operator:
    name: keyword.operator.expression.typeof.dw
    match: (?<!\.|\$)\btypeof\b(?!\$|\.)

  arrow-function:
    patterns:
    # parenthesized arrow
    - name: meta.arrow.dw
      begin: >-
        (?x)
        ((?<![})!\]])\s*
          (?=
            # sure shot arrow functions even if => is on new line
            (
              [(]\s*
              (
                ([)]\s*:) |                                   # ():
                ((\.\.\.\s*)?[_$[:alpha:]][_$[:alnum:]]*\s*:) # [(]param: | [(]...param:
              )
            ) |
            (
              [<]\s*[_$[:alpha:]][_$[:alnum:]]*\s+extends\s*[^\->] # < typeparam extends 
            ) |
            # arrow function possible to detect only with => on same line
            (
              (<([^<>=]|=[^<]|\<([^=<>]|=[^<])+\>)+>\s*)?                 # typeparameters
              \(([^()]|\([^()]*\))*\)                     # parameteres
              (\s*:\s*(.)*)?                              # return type
              \s*\->                                      # arrow operator
            )
          )
        )
      end: (?=(}|---|->)|\bvar\b|\binput\b|\boutput\b|\btype\b|\bfun\b|\bns\b|\bimport\b)
      patterns:
      - include: '#comment'
      - include: '#type-parameters'
      - include: '#function-parameters'
      # return type of the arrow
      - include: '#arrow-return-type'
    # arrow operator
    - name: meta.arrow.dw
      begin: "->"
      beginCaptures:
        '0': { name: storage.type.function.arrow.dw }
      end: (?<=\}|\S)(?<!=>)|((?!\{)(?=\S))
      patterns:
      - include: '#decl-block'
      - include: '#expression'

  arrow-return-type:
    name: meta.return.type.arrow.dw
    begin: '(?<=\))\s*(:)'
    beginCaptures:
      '1': { name: keyword.operator.type.annotation.dw }    
    end: (?=(}|---|->)|\bvar\b|\binput\b|\boutput\b|\btype\b|\bfun\b|\bns\b|\bimport\b)
    patterns:
    # TODO: handle the fn and constructor type specifically.
    # Handle returning of object type specifically here so as to not confuse it with the start of function block
    - begin: (?<=[:])(?=\s*\{)
      end: (?<=\})
      patterns:
      - include: '#type-object'
    - include: '#type-predicate-operator'
    - include: '#type'

  punctuation-comma:
    name: punctuation.separator.comma.dw
    match: ','

  punctuation-accessor:
    name: punctuation.accessor.dw
    match: '(\.\.\*|\.\.|\.\*|\.|::)'

  paren-expression:
    begin: \(
    beginCaptures:
      '0': {name: meta.brace.round.dw }
    end: \)
    endCaptures:
      '0': {name: meta.brace.round.dw }
    patterns:
    - include: '#expression'
    - include: '#punctuation-comma'

  qstring-double:
    name: string.quoted.double.dw
    begin: '"'
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.dw }
    end: '"'
    endCaptures:
      '1': { name: punctuation.definition.string.end.dw }
    patterns:
    - include: '#template-substitution-element'
    - include: '#string-character-escape'

  qstring-single:
    name: string.quoted.single.dw
    begin: "'"
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.dw }
    end: (\')|((?:[^\\\n])$)
    endCaptures:
      '1': { name: punctuation.definition.string.end.dw }
      '2': { name: invalid.illegal.newline.dw }
    patterns:
    - include: '#template-substitution-element'
    - include: '#string-character-escape'

  regex:
    patterns:
    - name: string.regexp.dw
      begin: (?<=[=(:,\[?+!]|---|case|->|&&|\|\||\*\/)\s*(\/)(?![\/*])(?=(?:[^\/\\\[]|\\.|\[([^\]\\]|\\.)+\])+\/(?![\/*])(?!\s*[a-zA-Z0-9_$]))
      beginCaptures:
        '1': {name: punctuation.definition.string.begin.dw}
      end: (/)
      endCaptures:
        '1': {name: punctuation.definition.string.end.dw}
      patterns:
      - include: '#regexp'
    # Check if complete regexp syntax
    - name: string.regexp.dw
      begin: (?<![_$[:alnum:])])\/(?![\/*])(?=(?:[^\/\\\[]|\\.|\[([^\]\\]|\\.)+\])+\/(?![\/*])(?!\s*[a-zA-Z0-9_$]))
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.dw}
      end: (/)
      endCaptures:
        '1': {name: punctuation.definition.string.end.dw}
      patterns:
      - include: '#regexp'

  # regexp syntax is taken from https://github.com/atom/language-javascript/
  regexp:
    patterns:
    - name: keyword.control.anchor.regexp
      match: \\[bB]|\^|\$
    - name: keyword.other.back-reference.regexp
      match: \\[1-9]\d*
    - name: keyword.operator.quantifier.regexp
      match: '[?+*]|\{(\d+,\d+|\d+,|,\d+|\d+)\}\??'
    - name: keyword.operator.or.regexp
      match: \|
    - name: meta.group.assertion.regexp
      begin: (\()((\?=)|(\?!))
      beginCaptures:
        '1': {name: punctuation.definition.group.regexp}
        '2': {name: punctuation.definition.group.assertion.regexp}
        '3': {name: meta.assertion.look-ahead.regexp}
        '4': {name: meta.assertion.negative-look-ahead.regexp}
      end: (\))
      endCaptures:
        '1': {name: punctuation.definition.group.regexp}
      patterns:
      - include: '#regexp'
    - name: meta.group.regexp
      begin: \((\?:)?
      beginCaptures:
        '0': {name: punctuation.definition.group.regexp}
        '1': {name: punctuation.definition.group.capture.regexp}
      end: \)
      endCaptures:
        '0': {name: punctuation.definition.group.regexp}
      patterns:
      - include: '#regexp'
    - name: constant.other.character-class.set.regexp
      begin: (\[)(\^)?
      beginCaptures:
        '1': {name: punctuation.definition.character-class.regexp}
        '2': {name: keyword.operator.negation.regexp}
      end: (\])
      endCaptures:
        '1': {name: punctuation.definition.character-class.regexp}
      patterns:
      - name: constant.other.character-class.range.regexp
        match: (?:.|(\\(?:[0-7]{3}|x\h\h|u\h\h\h\h))|(\\c[A-Z])|(\\.))\-(?:[^\]\\]|(\\(?:[0-7]{3}|x\h\h|u\h\h\h\h))|(\\c[A-Z])|(\\.))
        captures:
          '1': {name: constant.character.numeric.regexp}
          '2': {name: constant.character.control.regexp}
          '3': {name: constant.character.escape.backslash.regexp}
          '4': {name: constant.character.numeric.regexp}
          '5': {name: constant.character.control.regexp}
          '6': {name: constant.character.escape.backslash.regexp}
      - include: '#regex-character-class'
    - include: '#regex-character-class'

  regex-character-class:
    patterns:
    - name: constant.other.character-class.regexp
      match: \\[wWsSdDtrnvf]|\.
    - name: constant.character.numeric.regexp
      match: \\([0-7]{3}|x\h\h|u\h\h\h\h)
    - name: constant.character.control.regexp
      match: \\c[A-Z]
    - name: constant.character.escape.backslash.regexp
      match: \\.

  string:
    patterns:
    - include: '#qstring-single'
    - include: '#qstring-double'

  template:
    name: string.template.dw
    begin: '([_$[:alpha:]][_$[:alnum:]]*)?(`)'
    beginCaptures:
      '1': { name: entity.name.function.tagged-template.dw }
      '2': { name: punctuation.definition.string.template.begin.dw }
    end: '`'
    endCaptures:
      '0': { name: punctuation.definition.string.template.end.dw}
    patterns:
     - include: '#template-substitution-element'
     - include: '#string-character-escape'

  string-character-escape:
    name: constant.character.escape.dw
    match: \\(x\h{2}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)

  template-substitution-element:
    name: meta.template.expression.dw
    begin: \$\(
    beginCaptures:
      '0': { name: comment.template.dw }
    end: \)
    endCaptures:
      '0': { name: comment.template.dw }
    patterns:
      - include: '#expression'

  literal:
    patterns:
    - include: '#numeric-literal'
    - include: '#boolean-literal'
    - include: '#null-literal'
    - include: '#numericConstant-literal'
    - include: '#array-literal'

  array-literal:
    name: meta.array.literal.dw
    begin: \[
    beginCaptures:
      '0': { name: meta.brace.square.dw }
    end: \]
    endCaptures:
      '0': { name: meta.brace.square.dw }
    patterns:
    - include: '#expression'
    - include: '#punctuation-comma'

  numeric-literal:
    patterns:
    - name: constant.numeric.hex.dw
      match: \b(?<!\$)0(x|X)[0-9a-fA-F]+\b(?!\$)
    - name: constant.numeric.binary.dw
      match: \b(?<!\$)0(b|B)[01]+\b(?!\$)
    - name: constant.numeric.octal.dw
      match: \b(?<!\$)0(o|O)?[0-7]+\b(?!\$)
    - match: |-
        (?x)
        (?<!\$)(?:
          (?:\b[0-9]+(\.)[0-9]+[eE][+-]?[0-9]+\b)| # 1.1E+3
          (?:\b[0-9]+(\.)[eE][+-]?[0-9]+\b)|       # 1.E+3
          (?:\B(\.)[0-9]+[eE][+-]?[0-9]+\b)|       # .1E+3
          (?:\b[0-9]+[eE][+-]?[0-9]+\b)|            # 1E+3
          (?:\b[0-9]+(\.)[0-9]+\b)|                # 1.1
          (?:\b[0-9]+(\.)\B)|                      # 1.
          (?:\B(\.)[0-9]+\b)|                      # .1
          (?:\b[0-9]+\b(?!\.))                     # 1
        )(?!\$)
      captures:
        '0': {name: constant.numeric.decimal.dw}
        '1': {name: meta.delimiter.decimal.period.dw}
        '2': {name: meta.delimiter.decimal.period.dw}
        '3': {name: meta.delimiter.decimal.period.dw}
        '4': {name: meta.delimiter.decimal.period.dw}
        '5': {name: meta.delimiter.decimal.period.dw}
        '6': {name: meta.delimiter.decimal.period.dw}

  boolean-literal:
    patterns:
    - name: constant.language.boolean.true.dw
      match: (?<!\.|\$)\btrue\b(?!\$)
    - name: constant.language.boolean.false.dw
      match: (?<!\.|\$)\bfalse\b(?!\$)

  null-literal:
    name: constant.language.null.dw
    match: (?<!\.|\$)\bnull\b(?!\$)

  numericConstant-literal:
    patterns:
    - name: constant.language.nan.dw
      match: (?<!\.|\$)\bNaN\b(?!\$)
    - name: constant.language.infinity.dw
      match: (?<!\.|\$)\bInfinity\b(?!\$)

  access-modifier:
    name: storage.modifier.dw
    match: (?<!\.|\$)\b(abstract|public|protected|private|readonly|static)\b(?!\$|\.)

  comment:
    patterns:
    - name: comment.block.documentation.dw
      begin: /\*\*(?!/)
      beginCaptures:
        '0': { name: punctuation.definition.comment.dw }
      end: \*/
      endCaptures:
        '0': { name: punctuation.definition.comment.dw }
      patterns:
      - include: '#docblock'
    - name: comment.block.dw
      begin: (/\*)(?:\s*((@)internal)(?=\s|(\*/)))?
      beginCaptures:
        '1': { name: punctuation.definition.comment.dw }
        '2': { name: storage.type.internaldeclaration.dw }
        '3': { name: punctuation.decorator.internaldeclaration.dw }
      end: \*/
      endCaptures:
        '0': { name: punctuation.definition.comment.dw }
    - begin: (^[ \t]+)?((//)(?:\s*((@)internal)(?=\s|$))?)
      beginCaptures:
        '1': { name: punctuation.whitespace.comment.leading.dw }
        '2': { name: comment.line.double-slash.dw }
        '3': { name: punctuation.definition.comment.dw }
        '4': { name: storage.type.internaldeclaration.dw }
        '5': { name: punctuation.decorator.internaldeclaration.dw }
      end: (?=^)
      contentName: comment.line.double-slash.dw

  docblock:
    patterns:
    # @access private|protected|public
    - match: |-
        (?x)
        ((@)(?:access|api))
        \s+
        (private|protected|public)
        \b
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: constant.language.access-type.jsdoc }
    # @author name [<email>]
    - match: |-
        (?x)
        ((@)author)
        \s+
        (
          [^@\s<>*/]
          (?:[^@<>*/]|\*[^/])*
        )
        (?:
          \s*
          (<)
          ([^>\s]+)
          (>)
        )?
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: entity.name.type.instance.jsdoc }
        '4': { name: punctuation.definition.bracket.angle.begin.jsdoc }
        '5': { name: constant.other.email.link.underline.jsdoc }
        '6': { name: punctuation.definition.bracket.angle.end.jsdoc }
    # @borrows <that namepath> as <this namepath>
    - match: |-
        (?x)
        ((@)borrows) \s+
        ((?:[^@\s*/]|\*[^/])+)    # <that namepath>
        \s+ (as) \s+              # as
        ((?:[^@\s*/]|\*[^/])+)    # <this namepath>
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: entity.name.type.instance.jsdoc }
        '4': { name: keyword.operator.control.jsdoc }
        '5': { name: entity.name.type.instance.jsdoc }
    # @example text();
    - name: meta.example.jsdoc
      begin: ((@)example)\s+
      end: (?=@|\*/)
      beginCaptures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
      patterns:
      # Match to prevent leading asterisk being highlighted as JS
      - match: ^\s\*\s+
      # Leading <caption>…</caption> before example
      - contentName: constant.other.description.jsdoc
        begin: \G(<)caption(>)
        beginCaptures:
          '0': { name: entity.name.tag.inline.jsdoc }
          '1': { name: punctuation.definition.bracket.angle.begin.jsdoc }
          '2': { name: punctuation.definition.bracket.angle.end.jsdoc }
        end: (</)caption(>)|(?=\*/)
        endCaptures:
          '0': { name: entity.name.tag.inline.jsdoc }
          '1': { name: punctuation.definition.bracket.angle.begin.jsdoc }
          '2': { name: punctuation.definition.bracket.angle.end.jsdoc }
      # Highlighted JavaScript example
      - match: '[^\s@*](?:[^*]|\*[^/])*'
        captures:
          '0':
            name: source.embedded.dw
            # Commenting out the embedded pattern matching since sublime doesnt support this
            # patterns:
            # - include: source.dw
    # @kind type
    - match: >-
        (?x)
        ((@)kind)
        \s+
        (class|constant|event|external|file|function|member|mixin|module|namespace|typedef)
        \b
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: constant.language.symbol-type.jsdoc }
    # @see namepathOrURL
    - match: |-
        (?x)
        ((@)see)
        \s+
        (?:
          # URL
          (
            (?!
              # Avoid matching bare URIs (also acceptable as links)
              https?://
              |
              # Avoid matching {@inline tags}; we match those below
              (?:\[[^\[\]]*\])? # Possible description [preceding]{@tag}
              {@(?:link|linkcode|linkplain|tutorial)\b
            )
            # Matched namepath
            (?:[^\s*]|\*[^/])+
          )
          |
          # JSDoc namepath
          (
            (?!https?://)
            (?:[^@\s*/]|\*[^/])+
          )
        )
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: variable.other.link.underline.jsdoc }
        '4': { name: entity.name.type.instance.jsdoc }
    # @template Foo,Bar
    - match: |-
        (?x)
        ((@)template)
        \s+
        # One or more valid identifiers
        (?:
          ([A-Za-z_$]        # First character: non-numeric word character
          [\w$.\[\]]*)       # Rest of identifier
          (?:                # Possible list of additional identifiers
            \s* (,) \s*
            ([A-Za-z_$]
            [\w$.\[\]]*)
          )*
        )
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: variable.other.jsdoc }
        '4': { name: punctuation.delimiter.object.comma.jsdoc }
        '5': { name: variable.other.jsdoc }
    # Tags followed by an identifier token 
    # -  @<tag> identifier 
    - match: |-
        (?x)
        (
          (@)
          (?:arg|argument|const|constant|member|namespace|param|var)
        )
        \s+
        (
          [A-Za-z_$]
          [\w$.\[\]]*
        )
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: variable.other.jsdoc }
    # Tags followed by a type expression, then a namepath 
    # -  @<tag> {type} namepath 
    - begin: ((@)typedef)\s+(?={)
      beginCaptures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
      end: (?=\s|\*/|[^{}\[\]A-Za-z_$])
      patterns:
      - include: '#jsdoctype'
      - name: entity.name.type.instance.jsdoc
        match: (?:[^@\s*/]|\*[^/])+
    # Tags followed by a type expression, then an identifier 
    # -  @<tag> {type} identifier 
    - begin: >-
        ((@)(?:arg|argument|const|constant|member|namespace|param|prop|property|var))\s+(?={)
      beginCaptures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
      end: (?=\s|\*/|[^{}\[\]A-Za-z_$])
      patterns:
      - include: '#jsdoctype'
      - name: variable.other.jsdoc
        match: ([A-Za-z_$][\w$.\[\]]*)
      # Optional value
      - name: variable.other.jsdoc
        match: |-
          (?x)
          (\[)\s*
          [\w$]+
          (?:
            (?:\[\])?                                        # Foo[ ].bar properties within an array
            \.                                                # Foo.Bar namespaced parameter
            [\w$]+
          )*
          (?:
            \s*
            (=)                                                # [foo=bar] Default parameter value
            \s*
            (
              # The inner regexes are to stop the match early at */ and to not stop at escaped quotes
              (?:
                "(?:(?:\*(?!/))|(?:\\(?!"))|[^*\\])*?" |  # [foo="bar"] Double-quoted
                '(?:(?:\*(?!/))|(?:\\(?!'))|[^*\\])*?' |  # [foo='bar'] Single-quoted
                \[ (?:(?:\*(?!/))|[^*])*? \] |              # [foo=[1,2]] Array literal
                (?:(?:\*(?!/))|[^*])*?                        # Everything else
              )*
            )
          )?
          \s*(?:(\])((?:[^*\s]|\*[^\s/])+)?|(?=\*/))
        captures:
          '1': { name: punctuation.definition.optional-value.begin.bracket.square.jsdoc }
          '2': { name: keyword.operator.assignment.jsdoc }
          '3':
            name: source.embedded.dw
            # Commenting out the embedded pattern matching since sublime doesnt support this
            # patterns:
            #   - include: '#inline-tags'
            #   - include: source.js
          '4': { name: punctuation.definition.optional-value.end.bracket.square.jsdoc }
          '5': { name: invalid.illegal.syntax.jsdoc }

        begin: '\['
        end: '\]|(?=\*/)'
        patterns:
        - match: (=)((?:[^\]*]|\*[^/])*)
          captures:
            '1': { name: keyword.operator.assignment.jsdoc }
            '2':
              name: source.embedded.dw
              # Commenting out the embedded pattern matching since sublime doesnt support this
              # patterns:
              # - include: '#inline-tags'
              # - include: source.dw
        - include: '#brackets'
        - include: '#quotes'
    # Tags followed by a type expression 
    # -  @<tag> {type} 
    - begin: >-
        ((@)(?:define|enum|exception|implements|modifies|namespace|private|protected|returns?|suppress|throws|type))\s+(?={)
      beginCaptures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
      end: (?=\s|\*/|[^{}\[\]A-Za-z_$])
      patterns:
      - include: '#jsdoctype'
    # Tags followed by a namepath 
    # -  @<tag> namepath 
    - match: |-
        (?x)
        (
          (@)
          (?:alias|augments|callback|constructs|emits|event|fires|exports?
          |extends|external|function|func|host|lends|listens|interface|memberof!?
          |method|module|mixes|mixin|name|requires|see|this|typedef|uses)
        )
        \s+
        (
          (?:
            [^{}@\s*] | \*[^/]
          )+
        )
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: entity.name.type.instance.jsdoc }
    # Tags followed by a quoted arbitrary value 
    # -  @<tag> "Quoted value" 
    - contentName: variable.other.jsdoc
      begin: ((@)(?:default(?:value)?|license|version))\s+(([''"]))
      beginCaptures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: variable.other.jsdoc }
        '4': { name: punctuation.definition.string.begin.jsdoc }
      end: (\3)|(?=$|\*/)
      endCaptures:
        '0': { name: variable.other.jsdoc }
        '1': { name: punctuation.definition.string.end.jsdoc }
    # Tags followed by an arbitrary value 
    # -  @<tag> value 
    - match: ((@)(?:default(?:value)?|license|tutorial|variation|version))\s+([^\s*]+)
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: variable.other.jsdoc }
    # Tags without arguments, or a tag without expected arguments. Because JSDoc permits 
    # tags to be spread across lines, we should at least highlight the opening tag for 
    # stuff like this: 
    # 
    #    /** 
    #      * @param 
    #      * {type} 
    #      * name 
    - name: storage.type.class.jsdoc
      match: >-
        (?x) (@)
        (?:abstract|access|alias|api|arg|argument|async|attribute|augments|author|beta|borrows|bubbles
        |callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright
        |default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exception
        |exports?|extends|extension(?:_?for)?|external|externs|file|fileoverview|final|fires|for|func
        |function|global|host|ignore|implements|implicitCast|inherit[Dd]oc|inner|instance|interface
        |internal|kind|lends|license|listens|main|member|memberof!?|method|mixes|mixins?|modifies|module
        |name|namespace|noalias|nocollapse|nocompile|nosideeffects|override|overview|package|param|preserve
        |private|prop|property|protected|public|read[Oo]nly|record|require[ds]|returns?|see|since|static
        |struct|submodule|summary|suppress|template|this|throws|todo|tutorial|type|typedef|unrestricted
        |uses|var|variation|version|virtual|writeOnce)
        \b
      captures:
        '1': { name: punctuation.definition.block.tag.jsdoc }
    - include: '#inline-tags'

  brackets:
  # Balanced brackets (square or curly)
    patterns:
    - begin: '{'
      end: '}|(?=\*/)'
      patterns:
      - include: '#brackets'
    - begin: '\['
      end: '\]|(?=\*/)'
      patterns:
      - include: '#brackets'

  inline-tags:
    patterns:
    # Description preceding {@inline tag}
    - name: constant.other.description.jsdoc
      match: (\[)[^\]]+(\])(?={@(?:link|linkcode|linkplain|tutorial))
      captures:
        '1': { name: punctuation.definition.bracket.square.begin.jsdoc }
        '2': { name: punctuation.definition.bracket.square.end.jsdoc }
    # {@link|@tutorial …}
    - name: entity.name.type.instance.jsdoc
      begin: ({)((@)(?:link(?:code|plain)?|tutorial))\s*
      beginCaptures:
        '1': { name: punctuation.definition.bracket.curly.begin.jsdoc }
        '2': { name: storage.type.class.jsdoc }
        '3': { name: punctuation.definition.inline.tag.jsdoc }
      end: '}|(?=\*/)'
      endCaptures:
        '0': { name: punctuation.definition.bracket.curly.end.jsdoc }
      patterns:
      - match: \G((?=https?://)(?:[^|}\s*]|\*[/])+)(\|)?
        captures:
          '1': { name: variable.other.link.underline.jsdoc }
          '2': { name: punctuation.separator.pipe.jsdoc }
      - match: \G((?:[^{}@\s|*]|\*[^/])+)(\|)?
        captures:
          '1': { name: variable.other.description.jsdoc }
          '2': { name: punctuation.separator.pipe.jsdoc }

  quotes:
  # Balanced quotes
    patterns:
    - begin: ''''
      end: '''|(?=\*/)'
      patterns:
      - include: '#quotes'
    - begin: '"'
      end: '"|(?=\*/)'
      patterns:
      - include: '#quotes'

  jsdoctype:
  # {type}
    patterns:
    # {unclosed
    - name: invalid.illegal.type.jsdoc
      match: \G{(?:[^}*]|\*[^/}])+$
    - contentName: entity.name.type.instance.jsdoc
      begin: \G({)
      beginCaptures:
        '0': { name: entity.name.type.instance.jsdoc }
        '1': { name: punctuation.definition.bracket.curly.begin.jsdoc }
      end: ((}))\s*|(?=\*/)
      endCaptures:
        '1': { name: entity.name.type.instance.jsdoc }
        '2': { name: punctuation.definition.bracket.curly.end.jsdoc }
      patterns:
      - include: '#brackets'

...
